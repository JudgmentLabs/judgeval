from collections.abc import Mapping
from typing import (
    TYPE_CHECKING,
    Any,
    TypeVar,
    Union,
    cast,
)

from attrs import define as _attrs_define
from attrs import field as _attrs_field

from ..types import UNSET, Unset

if TYPE_CHECKING:
    from ..models.scorer_data_additional_metadata_type_0 import (
        ScorerDataAdditionalMetadataType0,
    )


T = TypeVar("T", bound="ScorerData")


@_attrs_define
class ScorerData:
    """ScorerData holds the information related to a single, completed Scorer evaluation run.

    For example, if running the Judgment Faithfulness scorer on an example, the ScorerData
    object will contain whether the example passed its threshold expectation, as well as more detailed
    information surrounding the evaluation run such as the claims and verdicts generated by the
    judge model(s).

        Attributes:
            name (str):
            threshold (float):
            success (bool):
            score (Union[None, Unset, float]):
            reason (Union[None, Unset, str]):
            strict_mode (Union[None, Unset, bool]):
            evaluation_model (Union[Unset, list[str], str]):
            error (Union[None, Unset, str]):
            evaluation_cost (Union[None, Unset, float]):
            verbose_logs (Union[None, Unset, str]):
            additional_metadata (Union['ScorerDataAdditionalMetadataType0', None, Unset]):
    """

    name: str
    threshold: float
    success: bool
    score: Union[None, Unset, float] = UNSET
    reason: Union[None, Unset, str] = UNSET
    strict_mode: Union[None, Unset, bool] = UNSET
    evaluation_model: Union[Unset, list[str], str] = UNSET
    error: Union[None, Unset, str] = UNSET
    evaluation_cost: Union[None, Unset, float] = UNSET
    verbose_logs: Union[None, Unset, str] = UNSET
    additional_metadata: Union["ScorerDataAdditionalMetadataType0", None, Unset] = UNSET
    additional_properties: dict[str, Any] = _attrs_field(init=False, factory=dict)

    def to_dict(self) -> dict[str, Any]:
        from ..models.scorer_data_additional_metadata_type_0 import (
            ScorerDataAdditionalMetadataType0,
        )

        name = self.name

        threshold = self.threshold

        success = self.success

        score: Union[None, Unset, float]
        if isinstance(self.score, Unset):
            score = UNSET
        else:
            score = self.score

        reason: Union[None, Unset, str]
        if isinstance(self.reason, Unset):
            reason = UNSET
        else:
            reason = self.reason

        strict_mode: Union[None, Unset, bool]
        if isinstance(self.strict_mode, Unset):
            strict_mode = UNSET
        else:
            strict_mode = self.strict_mode

        evaluation_model: Union[Unset, list[str], str]
        if isinstance(self.evaluation_model, Unset):
            evaluation_model = UNSET
        elif isinstance(self.evaluation_model, list):
            evaluation_model = self.evaluation_model

        else:
            evaluation_model = self.evaluation_model

        error: Union[None, Unset, str]
        if isinstance(self.error, Unset):
            error = UNSET
        else:
            error = self.error

        evaluation_cost: Union[None, Unset, float]
        if isinstance(self.evaluation_cost, Unset):
            evaluation_cost = UNSET
        else:
            evaluation_cost = self.evaluation_cost

        verbose_logs: Union[None, Unset, str]
        if isinstance(self.verbose_logs, Unset):
            verbose_logs = UNSET
        else:
            verbose_logs = self.verbose_logs

        additional_metadata: Union[None, Unset, dict[str, Any]]
        if isinstance(self.additional_metadata, Unset):
            additional_metadata = UNSET
        elif isinstance(self.additional_metadata, ScorerDataAdditionalMetadataType0):
            additional_metadata = self.additional_metadata.to_dict()
        else:
            additional_metadata = self.additional_metadata

        field_dict: dict[str, Any] = {}
        field_dict.update(self.additional_properties)
        field_dict.update(
            {
                "name": name,
                "threshold": threshold,
                "success": success,
            }
        )
        if score is not UNSET:
            field_dict["score"] = score
        if reason is not UNSET:
            field_dict["reason"] = reason
        if strict_mode is not UNSET:
            field_dict["strict_mode"] = strict_mode
        if evaluation_model is not UNSET:
            field_dict["evaluation_model"] = evaluation_model
        if error is not UNSET:
            field_dict["error"] = error
        if evaluation_cost is not UNSET:
            field_dict["evaluation_cost"] = evaluation_cost
        if verbose_logs is not UNSET:
            field_dict["verbose_logs"] = verbose_logs
        if additional_metadata is not UNSET:
            field_dict["additional_metadata"] = additional_metadata

        return field_dict

    @classmethod
    def from_dict(cls: type[T], src_dict: Mapping[str, Any]) -> T:
        from ..models.scorer_data_additional_metadata_type_0 import (
            ScorerDataAdditionalMetadataType0,
        )

        d = dict(src_dict)
        name = d.pop("name")

        threshold = d.pop("threshold")

        success = d.pop("success")

        def _parse_score(data: object) -> Union[None, Unset, float]:
            if data is None:
                return data
            if isinstance(data, Unset):
                return data
            return cast(Union[None, Unset, float], data)

        score = _parse_score(d.pop("score", UNSET))

        def _parse_reason(data: object) -> Union[None, Unset, str]:
            if data is None:
                return data
            if isinstance(data, Unset):
                return data
            return cast(Union[None, Unset, str], data)

        reason = _parse_reason(d.pop("reason", UNSET))

        def _parse_strict_mode(data: object) -> Union[None, Unset, bool]:
            if data is None:
                return data
            if isinstance(data, Unset):
                return data
            return cast(Union[None, Unset, bool], data)

        strict_mode = _parse_strict_mode(d.pop("strict_mode", UNSET))

        def _parse_evaluation_model(data: object) -> Union[Unset, list[str], str]:
            if isinstance(data, Unset):
                return data
            try:
                if not isinstance(data, list):
                    raise TypeError()
                evaluation_model_type_0 = cast(list[str], data)

                return evaluation_model_type_0
            except:  # noqa: E722
                pass
            return cast(Union[Unset, list[str], str], data)

        evaluation_model = _parse_evaluation_model(d.pop("evaluation_model", UNSET))

        def _parse_error(data: object) -> Union[None, Unset, str]:
            if data is None:
                return data
            if isinstance(data, Unset):
                return data
            return cast(Union[None, Unset, str], data)

        error = _parse_error(d.pop("error", UNSET))

        def _parse_evaluation_cost(data: object) -> Union[None, Unset, float]:
            if data is None:
                return data
            if isinstance(data, Unset):
                return data
            return cast(Union[None, Unset, float], data)

        evaluation_cost = _parse_evaluation_cost(d.pop("evaluation_cost", UNSET))

        def _parse_verbose_logs(data: object) -> Union[None, Unset, str]:
            if data is None:
                return data
            if isinstance(data, Unset):
                return data
            return cast(Union[None, Unset, str], data)

        verbose_logs = _parse_verbose_logs(d.pop("verbose_logs", UNSET))

        def _parse_additional_metadata(
            data: object,
        ) -> Union["ScorerDataAdditionalMetadataType0", None, Unset]:
            if data is None:
                return data
            if isinstance(data, Unset):
                return data
            try:
                if not isinstance(data, dict):
                    raise TypeError()
                additional_metadata_type_0 = (
                    ScorerDataAdditionalMetadataType0.from_dict(data)
                )

                return additional_metadata_type_0
            except:  # noqa: E722
                pass
            return cast(Union["ScorerDataAdditionalMetadataType0", None, Unset], data)

        additional_metadata = _parse_additional_metadata(
            d.pop("additional_metadata", UNSET)
        )

        scorer_data = cls(
            name=name,
            threshold=threshold,
            success=success,
            score=score,
            reason=reason,
            strict_mode=strict_mode,
            evaluation_model=evaluation_model,
            error=error,
            evaluation_cost=evaluation_cost,
            verbose_logs=verbose_logs,
            additional_metadata=additional_metadata,
        )

        scorer_data.additional_properties = d
        return scorer_data

    @property
    def additional_keys(self) -> list[str]:
        return list(self.additional_properties.keys())

    def __getitem__(self, key: str) -> Any:
        return self.additional_properties[key]

    def __setitem__(self, key: str, value: Any) -> None:
        self.additional_properties[key] = value

    def __delitem__(self, key: str) -> None:
        del self.additional_properties[key]

    def __contains__(self, key: str) -> bool:
        return key in self.additional_properties
